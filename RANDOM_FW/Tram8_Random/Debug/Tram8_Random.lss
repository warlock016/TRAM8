
Tram8_Random.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000be8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000007e  00800060  00000be8  00000c7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000032  008000de  008000de  00000cfa  2**0
                  ALLOC
  3 .comment      00000024  00000000  00000000  00000cfa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d20  2**2
                  CONTENTS, READONLY, OCTETS
  5 .debug_aranges 000001b0  00000000  00000000  00000d60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   000020e1  00000000  00000000  00000f10  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 00000e48  00000000  00000000  00002ff1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00002dd5  00000000  00000000  00003e39  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  000002f8  00000000  00000000  00006c10  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00000cbc  00000000  00000000  00006f08  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    000013ef  00000000  00000000  00007bc4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 000002e8  00000000  00000000  00008fb3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	72 c1       	rjmp	.+740    	; 0x2f2 <__vector_6>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	99 c1       	rjmp	.+818    	; 0x34a <__vector_11>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0

00000034 <.Loc.1>:
  34:	a0 e6       	ldi	r26, 0x60	; 96

00000036 <.Loc.2>:
  36:	b0 e0       	ldi	r27, 0x00	; 0

00000038 <.Loc.3>:
  38:	e8 ee       	ldi	r30, 0xE8	; 232

0000003a <.Loc.4>:
  3a:	fb e0       	ldi	r31, 0x0B	; 11

0000003c <.Loc.5>:
  3c:	02 c0       	rjmp	.+4      	; 0x42 <.L__do_copy_data_start>

0000003e <.L__do_copy_data_loop>:
  3e:	05 90       	lpm	r0, Z+

00000040 <.Loc.7>:
  40:	0d 92       	st	X+, r0

00000042 <.L__do_copy_data_start>:
  42:	ae 3d       	cpi	r26, 0xDE	; 222

00000044 <.Loc.9>:
  44:	b1 07       	cpc	r27, r17

00000046 <.Loc.10>:
  46:	d9 f7       	brne	.-10     	; 0x3e <.L__do_copy_data_loop>

00000048 <__do_clear_bss>:
  48:	21 e0       	ldi	r18, 0x01	; 1

0000004a <.Loc.1>:
  4a:	ae ed       	ldi	r26, 0xDE	; 222

0000004c <.Loc.2>:
  4c:	b0 e0       	ldi	r27, 0x00	; 0

0000004e <.Loc.3>:
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.Loc.5>

00000050 <.Loc.4>:
  50:	1d 92       	st	X+, r1

00000052 <.Loc.5>:
  52:	a0 31       	cpi	r26, 0x10	; 16

00000054 <.Loc.6>:
  54:	b2 07       	cpc	r27, r18

00000056 <.Loc.7>:
  56:	e1 f7       	brne	.-8      	; 0x50 <.Loc.4>

00000058 <L0^A>:
  58:	4b d2       	rcall	.+1174   	; 0x4f0 <main>
  5a:	a0 c5       	rjmp	.+2880   	; 0xb9c <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <TWI_WRITE_BULK>:
		return 1;
	
}


uint8_t TWI_WRITE_BULK(uint8_t ICAddr, uint8_t Offset, uint8_t Length, uint8_t (*Filldata)[]){
  5e:	a2 2f       	mov	r26, r18
  60:	b3 2f       	mov	r27, r19

00000062 <.Loc.295>:
			
		uint8_t Returnval = 0;
		
		TWSR=0;					//prescaler = 1 = (4^0)
  62:	11 b8       	out	0x01, r1	; 1

00000064 <.Loc.298>:
		TWBR=TW_Bautrate;
  64:	9c e0       	ldi	r25, 0x0C	; 12
  66:	90 b9       	out	0x00, r25	; 0

00000068 <.Loc.300>:
		
		//STOP
		TWCR=TWCR_STOP;
  68:	94 e9       	ldi	r25, 0x94	; 148
  6a:	96 bf       	out	0x36, r25	; 54

0000006c <.Loc.302>:

		
		/****Start ****/
		TWCR=TWCR_START;
  6c:	94 ea       	ldi	r25, 0xA4	; 164
  6e:	96 bf       	out	0x36, r25	; 54

00000070 <.L71>:
		while (!(TWCR & (1<<TWINT)))
  70:	06 b6       	in	r0, 0x36	; 54
  72:	07 fe       	sbrs	r0, 7
  74:	fd cf       	rjmp	.-6      	; 0x70 <.L71>

00000076 <.Loc.307>:
		{
			//warten bis interupt-flag gesetzt ist
		}
		if (TW_STATUS!=TW_START)
  76:	91 b1       	in	r25, 0x01	; 1

00000078 <.Loc.309>:
  78:	98 7f       	andi	r25, 0xF8	; 248
  7a:	98 30       	cpi	r25, 0x08	; 8
  7c:	79 f5       	brne	.+94     	; 0xdc <.L88>

0000007e <.Loc.310>:

		


		/****Adresse ****/
		TWDR=	ICAddr | TW_WRITE;					//Adresse  write
  7e:	83 b9       	out	0x03, r24	; 3

00000080 <.Loc.312>:
		TWCR=TWCR_SEND;
  80:	84 e8       	ldi	r24, 0x84	; 132

00000082 <.LVL41>:
  82:	86 bf       	out	0x36, r24	; 54

00000084 <.L74>:
		while (!(TWCR & (1<<TWINT)))
  84:	06 b6       	in	r0, 0x36	; 54
  86:	07 fe       	sbrs	r0, 7
  88:	fd cf       	rjmp	.-6      	; 0x84 <.L74>

0000008a <.Loc.318>:
		{
			//warten bis interupt-flag gesetzt ist
		}
		if (TW_STATUS!=TW_MT_SLA_ACK)
  8a:	81 b1       	in	r24, 0x01	; 1

0000008c <.Loc.320>:
  8c:	88 7f       	andi	r24, 0xF8	; 248
  8e:	88 31       	cpi	r24, 0x18	; 24
  90:	49 f5       	brne	.+82     	; 0xe4 <.L89>

00000092 <.Loc.321>:
			return 0;
		}
		
		
		/****Auswahl Register + auto increment=0****/
		TWDR=Offset;
  92:	63 b9       	out	0x03, r22	; 3

00000094 <.Loc.323>:
		TWCR=TWCR_SEND;
  94:	84 e8       	ldi	r24, 0x84	; 132
  96:	86 bf       	out	0x36, r24	; 54

00000098 <.L76>:
		while (!(TWCR & (1<<TWINT)))
  98:	06 b6       	in	r0, 0x36	; 54
  9a:	07 fe       	sbrs	r0, 7
  9c:	fd cf       	rjmp	.-6      	; 0x98 <.L76>

0000009e <.Loc.328>:
		{
			//warten bis interupt-flag gesetzt ist
		}
		//Ueberpruefen, ob Daten angekommen sind
		if (TW_STATUS!=TW_MT_DATA_ACK)
  9e:	81 b1       	in	r24, 0x01	; 1

000000a0 <.Loc.330>:
  a0:	88 7f       	andi	r24, 0xF8	; 248
  a2:	88 32       	cpi	r24, 0x28	; 40
  a4:	19 f5       	brne	.+70     	; 0xec <.L77>

000000a6 <.LVL43>:
		}
		
		
		uint8_t i = 0;
		
		for (i=0;i<Length;i++){
  a6:	44 23       	and	r20, r20
  a8:	a9 f0       	breq	.+42     	; 0xd4 <.L79>
  aa:	fd 01       	movw	r30, r26
  ac:	9d 01       	movw	r18, r26

000000ae <.LVL44>:
  ae:	2f 5f       	subi	r18, 0xFF	; 255
  b0:	3f 4f       	sbci	r19, 0xFF	; 255
  b2:	41 50       	subi	r20, 0x01	; 1

000000b4 <.LVL45>:
  b4:	24 0f       	add	r18, r20
  b6:	31 1d       	adc	r19, r1

000000b8 <.Loc.335>:
			/****Übertragen Wert****/
			TWDR = (*Filldata)[i];
			TWCR=TWCR_SEND;
  b8:	94 e8       	ldi	r25, 0x84	; 132

000000ba <.L82>:
			TWDR = (*Filldata)[i];
  ba:	81 91       	ld	r24, Z+

000000bc <.LVL47>:
  bc:	83 b9       	out	0x03, r24	; 3

000000be <.Loc.339>:
			TWCR=TWCR_SEND;
  be:	96 bf       	out	0x36, r25	; 54

000000c0 <.L80>:
			while (!(TWCR & (1<<TWINT)))
  c0:	06 b6       	in	r0, 0x36	; 54
  c2:	07 fe       	sbrs	r0, 7
  c4:	fd cf       	rjmp	.-6      	; 0xc0 <.L80>

000000c6 <.Loc.344>:
			{
				//warten bis interupt-flag gesetzt ist
			}
			//Ueberpruefen, ob Daten angekommen sind
			if (TW_STATUS!=TW_MT_DATA_ACK)
  c6:	81 b1       	in	r24, 0x01	; 1

000000c8 <.Loc.346>:
  c8:	88 7f       	andi	r24, 0xF8	; 248
  ca:	88 32       	cpi	r24, 0x28	; 40
  cc:	99 f4       	brne	.+38     	; 0xf4 <.L90>

000000ce <.LVL48>:
		for (i=0;i<Length;i++){
  ce:	e2 17       	cp	r30, r18
  d0:	f3 07       	cpc	r31, r19
  d2:	99 f7       	brne	.-26     	; 0xba <.L82>

000000d4 <.L79>:
			
		}
		
	
		//STOP
		TWCR=TWCR_STOP;
  d4:	84 e9       	ldi	r24, 0x94	; 148
  d6:	86 bf       	out	0x36, r24	; 54

000000d8 <.Loc.352>:

		return 1;
  d8:	81 e0       	ldi	r24, 0x01	; 1

000000da <.Loc.354>:
	
	
	
		return 0;
}
  da:	08 95       	ret

000000dc <.L88>:

void TWI_ERROR(void){
	
		TWCR=TWCR_STOP;
  dc:	84 e9       	ldi	r24, 0x94	; 148

000000de <.LVL51>:
  de:	86 bf       	out	0x36, r24	; 54

000000e0 <.LBE50>:
			return 0;
  e0:	80 e0       	ldi	r24, 0x00	; 0

000000e2 <.LBB53>:
		
	#ifdef MY_DEBUG
		printf("TWI Error - Status Byte: %x \n",TW_STATUS);	
	#endif
	
	return;
  e2:	08 95       	ret

000000e4 <.L89>:
		TWCR=TWCR_STOP;
  e4:	84 e9       	ldi	r24, 0x94	; 148
  e6:	86 bf       	out	0x36, r24	; 54

000000e8 <.LBE54>:
			return 0;
  e8:	80 e0       	ldi	r24, 0x00	; 0

000000ea <.LBB57>:
	return;
  ea:	08 95       	ret

000000ec <.L77>:
		TWCR=TWCR_STOP;
  ec:	84 e9       	ldi	r24, 0x94	; 148
  ee:	86 bf       	out	0x36, r24	; 54

000000f0 <.LBE58>:
			return 0;
  f0:	80 e0       	ldi	r24, 0x00	; 0

000000f2 <.LBB61>:
	return;
  f2:	08 95       	ret

000000f4 <.L90>:
		TWCR=TWCR_STOP;
  f4:	84 e9       	ldi	r24, 0x94	; 148
  f6:	86 bf       	out	0x36, r24	; 54

000000f8 <.LBE62>:
				return 0;
  f8:	80 e0       	ldi	r24, 0x00	; 0

000000fa <.LBB65>:
	return;
  fa:	08 95       	ret

000000fc <set_pin_inv>:
}

void set_pin_inv(uint8_t pinnr)
{
	// inverted cos of 74HC1G14 inverter
	switch (pinnr)
  fc:	88 30       	cpi	r24, 0x08	; 8
  fe:	a0 f4       	brcc	.+40     	; 0x128 <.L1>
 100:	e8 2f       	mov	r30, r24
 102:	f0 e0       	ldi	r31, 0x00	; 0
 104:	e0 53       	subi	r30, 0x30	; 48
 106:	fa 4f       	sbci	r31, 0xFA	; 250
 108:	09 94       	ijmp

0000010a <.L11>:
	{
	case 0:
		PORTB &= 0xFE;
 10a:	c0 98       	cbi	0x18, 0	; 24

0000010c <.Loc.4>:
		break;
 10c:	08 95       	ret

0000010e <.L10>:
	case 1:
		PORTD &= 0xFD;
 10e:	91 98       	cbi	0x12, 1	; 18

00000110 <.Loc.7>:
		break;
 110:	08 95       	ret

00000112 <.L9>:
	case 2:
		PORTD &= 0xFB;
 112:	92 98       	cbi	0x12, 2	; 18

00000114 <.Loc.10>:
		break;
 114:	08 95       	ret

00000116 <.L8>:
	case 3:
		PORTD &= 0xF7;
 116:	93 98       	cbi	0x12, 3	; 18

00000118 <.Loc.13>:
		break;
 118:	08 95       	ret

0000011a <.L7>:
	case 4:
		PORTD &= 0xEF;
 11a:	94 98       	cbi	0x12, 4	; 18

0000011c <.Loc.16>:
		break;
 11c:	08 95       	ret

0000011e <.L6>:
	case 5:
		PORTD &= 0xDF;
 11e:	95 98       	cbi	0x12, 5	; 18

00000120 <.Loc.19>:
		break;
 120:	08 95       	ret

00000122 <.L5>:
	case 6:
		PORTD &= 0xBF;
 122:	96 98       	cbi	0x12, 6	; 18

00000124 <.Loc.22>:
		break;
 124:	08 95       	ret

00000126 <.L3>:
	case 7:
		PORTD &= 0x7F;
 126:	97 98       	cbi	0x12, 7	; 18

00000128 <.L1>:
	default:
		break;
	}

	return;
}
 128:	08 95       	ret

0000012a <clear_pin_inv>:

void clear_pin_inv(uint8_t pinnr)
{
	switch (pinnr)
 12a:	88 30       	cpi	r24, 0x08	; 8
 12c:	a0 f4       	brcc	.+40     	; 0x156 <.L12>
 12e:	e8 2f       	mov	r30, r24
 130:	f0 e0       	ldi	r31, 0x00	; 0
 132:	e8 52       	subi	r30, 0x28	; 40
 134:	fa 4f       	sbci	r31, 0xFA	; 250
 136:	09 94       	ijmp

00000138 <.L22>:
	{
	case 0:
		PORTB |= 0x01;
 138:	c0 9a       	sbi	0x18, 0	; 24

0000013a <.Loc.32>:
		break;
 13a:	08 95       	ret

0000013c <.L21>:
	case 1:
		PORTD |= 0x02;
 13c:	91 9a       	sbi	0x12, 1	; 18

0000013e <.Loc.35>:
		break;
 13e:	08 95       	ret

00000140 <.L20>:
	case 2:
		PORTD |= 0x04;
 140:	92 9a       	sbi	0x12, 2	; 18

00000142 <.Loc.38>:
		break;
 142:	08 95       	ret

00000144 <.L19>:
	case 3:
		PORTD |= 0x08;
 144:	93 9a       	sbi	0x12, 3	; 18

00000146 <.Loc.41>:
		break;
 146:	08 95       	ret

00000148 <.L18>:
	case 4:
		PORTD |= 0x10;
 148:	94 9a       	sbi	0x12, 4	; 18

0000014a <.Loc.44>:
		break;
 14a:	08 95       	ret

0000014c <.L17>:
	case 5:
		PORTD |= 0x20;
 14c:	95 9a       	sbi	0x12, 5	; 18

0000014e <.Loc.47>:
		break;
 14e:	08 95       	ret

00000150 <.L16>:
	case 6:
		PORTD |= 0x40;
 150:	96 9a       	sbi	0x12, 6	; 18

00000152 <.Loc.50>:
		break;
 152:	08 95       	ret

00000154 <.L14>:
	case 7:
		PORTD |= 0x80;
 154:	97 9a       	sbi	0x12, 7	; 18

00000156 <.L12>:
	default:
		break;
	}

	return;
}
 156:	08 95       	ret

00000158 <note_off>:

midi_event_callback_t note_off(char chan, char data1, char data2)
{
	// set_LED(DISABLE);

	if((chan & 0x0F) != midi_channel) return; // wrong channel
 158:	8f 70       	andi	r24, 0x0F	; 15

0000015a <.LVL3>:
 15a:	90 91 e7 00 	lds	r25, 0x00E7	; 0x8000e7 <midi_channel>
 15e:	98 13       	cpse	r25, r24
 160:	29 c0       	rjmp	.+82     	; 0x1b4 <.L24>

00000162 <.Loc.60>:
	if(midi_note_cnt < 1) return; // no notes
 162:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <midi_note_cnt>

00000166 <.Loc.62>:
 166:	88 23       	and	r24, r24
 168:	29 f1       	breq	.+74     	; 0x1b4 <.L24>

0000016a <.Loc.63>:
	
	midi_note_cnt--;
 16a:	3f ef       	ldi	r19, 0xFF	; 255
 16c:	38 0f       	add	r19, r24
 16e:	30 93 e6 00 	sts	0x00E6, r19	; 0x8000e6 <midi_note_cnt>

00000172 <.LBB20>:

	int pos = -1;

	for (int i = 0; i < maxNotes; i++)
 172:	e0 ee       	ldi	r30, 0xE0	; 224
 174:	f0 e0       	ldi	r31, 0x00	; 0

00000176 <.Loc.69>:
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	80 e0       	ldi	r24, 0x00	; 0

0000017a <.L26>:
	{
		if (data1 == midi_note_buf[i])
 17a:	21 91       	ld	r18, Z+

0000017c <.Loc.72>:
 17c:	26 17       	cp	r18, r22
 17e:	89 f0       	breq	.+34     	; 0x1a2 <.L25>

00000180 <.Loc.73>:
	for (int i = 0; i < maxNotes; i++)
 180:	01 96       	adiw	r24, 0x01	; 1

00000182 <.Loc.75>:
 182:	86 30       	cpi	r24, 0x06	; 6
 184:	91 05       	cpc	r25, r1
 186:	c9 f7       	brne	.-14     	; 0x17a <.L26>

00000188 <.L27>:
		}
	}

	if(pos == -1)
	{
		pos = midi_note_cnt % maxNotes;
 188:	8b ea       	ldi	r24, 0xAB	; 171

0000018a <.LVL8>:
 18a:	38 9f       	mul	r19, r24
 18c:	81 2d       	mov	r24, r1
 18e:	11 24       	eor	r1, r1
 190:	86 95       	lsr	r24
 192:	86 95       	lsr	r24
 194:	98 2f       	mov	r25, r24
 196:	99 0f       	add	r25, r25
 198:	89 0f       	add	r24, r25
 19a:	88 0f       	add	r24, r24
 19c:	38 1b       	sub	r19, r24
 19e:	83 2f       	mov	r24, r19

000001a0 <.LVL9>:
 1a0:	03 c0       	rjmp	.+6      	; 0x1a8 <.L28>

000001a2 <.L25>:
	if(pos == -1)
 1a2:	8f 3f       	cpi	r24, 0xFF	; 255
 1a4:	98 07       	cpc	r25, r24
 1a6:	81 f3       	breq	.-32     	; 0x188 <.L27>

000001a8 <.L28>:

	uint8_t dac_pos = pos + offset;
	
	//max5825_set_load_channel(pos + offset, 0xFFFF);
	//max5825_set_load_channel(dac_pos, 0x0);
	(*clear_pin_ptr)(dac_pos);
 1a8:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 1ac:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 1b0:	8e 5f       	subi	r24, 0xFE	; 254

000001b2 <.LVL12>:
 1b2:	09 95       	icall

000001b4 <.L24>:

	return;
}
 1b4:	08 95       	ret

000001b6 <run>:
	if(!midi_clock_run)
 1b6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <midi_clock_run>

000001ba <.LVL15>:
 1ba:	81 11       	cpse	r24, r1

000001bc <.L31>:
}
 1bc:	08 95       	ret

000001be <.LVL17>:
		max5825_set_load_channel(0, 0xFFFF);
 1be:	6f ef       	ldi	r22, 0xFF	; 255
 1c0:	7f ef       	ldi	r23, 0xFF	; 255

000001c2 <.LVL18>:
 1c2:	e7 d1       	rcall	.+974    	; 0x592 <max5825_set_load_channel>

000001c4 <.LVL19>:
		midi_clock_tick_cntr = 0;
 1c4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <midi_clock_tick_cntr>

000001c8 <.Loc.100>:
		midi_clock_run = 1;
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <midi_clock_run>
 1ce:	f6 cf       	rjmp	.-20     	; 0x1bc <.L31>

000001d0 <cont>:
	if(!midi_clock_run)
 1d0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <midi_clock_run>

000001d4 <.LVL21>:
 1d4:	81 11       	cpse	r24, r1

000001d6 <.L34>:
}
 1d6:	08 95       	ret

000001d8 <.LVL23>:
		max5825_set_load_channel(0, 0xFFFF);
 1d8:	6f ef       	ldi	r22, 0xFF	; 255
 1da:	7f ef       	ldi	r23, 0xFF	; 255

000001dc <.LVL24>:
 1dc:	da d1       	rcall	.+948    	; 0x592 <max5825_set_load_channel>

000001de <.LVL25>:
		midi_clock_run = 1;
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <midi_clock_run>
 1e4:	f8 cf       	rjmp	.-16     	; 0x1d6 <.L34>

000001e6 <stop>:
	if(midi_clock_run)
 1e6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <midi_clock_run>

000001ea <.LVL27>:
 1ea:	81 11       	cpse	r24, r1
 1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <.L38>

000001ee <.L37>:
}
 1ee:	08 95       	ret

000001f0 <.L38>:
		max5825_set_load_channel(0, 0);
 1f0:	70 e0       	ldi	r23, 0x00	; 0
 1f2:	60 e0       	ldi	r22, 0x00	; 0

000001f4 <.LVL30>:
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	cd d1       	rcall	.+922    	; 0x592 <max5825_set_load_channel>

000001f8 <.LVL31>:
		midi_clock_run = 0;
 1f8:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <midi_clock_run>
 1fc:	f8 cf       	rjmp	.-16     	; 0x1ee <.L37>

000001fe <note_on>:

midi_event_callback_t note_on(char chan, char data1, char data2)
{
 1fe:	cf 93       	push	r28

00000200 <.Loc.124>:
	// set_LED(ENABLE);

	if((chan & 0x0F) != midi_channel) return; // wrong channel
 200:	98 2f       	mov	r25, r24
 202:	9f 70       	andi	r25, 0x0F	; 15
 204:	20 91 e7 00 	lds	r18, 0x00E7	; 0x8000e7 <midi_channel>
 208:	29 13       	cpse	r18, r25
 20a:	37 c0       	rjmp	.+110    	; 0x27a <.L40>

0000020c <.Loc.126>:

	if(data2 == 0)
 20c:	44 23       	and	r20, r20
 20e:	e9 f0       	breq	.+58     	; 0x24a <.L45>

00000210 <.Loc.128>:
	{
		note_off(chan, data1, data2);
		return;
	}

	uint8_t pos = (midi_note_cnt % maxNotes);
 210:	20 91 e6 00 	lds	r18, 0x00E6	; 0x8000e6 <midi_note_cnt>
 214:	8b ea       	ldi	r24, 0xAB	; 171

00000216 <.LVL33>:
 216:	28 9f       	mul	r18, r24
 218:	81 2d       	mov	r24, r1
 21a:	11 24       	eor	r1, r1
 21c:	86 95       	lsr	r24
 21e:	86 95       	lsr	r24
 220:	98 2f       	mov	r25, r24
 222:	99 0f       	add	r25, r25
 224:	89 0f       	add	r24, r25
 226:	88 0f       	add	r24, r24
 228:	28 1b       	sub	r18, r24

0000022a <.LVL34>:
	midi_note_buf[pos] = data1;
 22a:	e2 2f       	mov	r30, r18
 22c:	f0 e0       	ldi	r31, 0x00	; 0

0000022e <.Loc.133>:
 22e:	e0 52       	subi	r30, 0x20	; 32
 230:	ff 4f       	sbci	r31, 0xFF	; 255
 232:	60 83       	st	Z, r22

00000234 <.Loc.134>:

	uint8_t dac_pos = pos + offset;
 234:	c2 e0       	ldi	r28, 0x02	; 2
 236:	c2 0f       	add	r28, r18

00000238 <.LVL35>:
	uint8_t voct_pos = data1 - midi_note_offset;
 238:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <midi_note_offset>

0000023c <.LVL36>:

	if(data1 < midi_note_offset)
 23c:	68 17       	cp	r22, r24
 23e:	38 f0       	brcs	.+14     	; 0x24e <.L44>

00000240 <.Loc.140>:
	uint8_t voct_pos = data1 - midi_note_offset;
 240:	68 1b       	sub	r22, r24

00000242 <.LVL37>:
 242:	6c 33       	cpi	r22, 0x3C	; 60
 244:	28 f0       	brcs	.+10     	; 0x250 <.L42>
 246:	6b e3       	ldi	r22, 0x3B	; 59

00000248 <.LVL38>:
 248:	03 c0       	rjmp	.+6      	; 0x250 <.L42>

0000024a <.L45>:
		note_off(chan, data1, data2);
 24a:	86 df       	rcall	.-244    	; 0x158 <note_off>

0000024c <.LVL40>:
		return;
 24c:	16 c0       	rjmp	.+44     	; 0x27a <.L40>

0000024e <.L44>:
	{
		voct_pos = 0;
 24e:	60 e0       	ldi	r22, 0x00	; 0

00000250 <.L42>:
	if(voct_pos >= voct_range)
	{
		voct_pos = 59;
	}

	uint16_t dac_val = voct_lookup[voct_pos];
 250:	e6 2f       	mov	r30, r22

00000252 <.LVL43>:
 252:	f0 e0       	ldi	r31, 0x00	; 0

00000254 <.Loc.151>:
 254:	ee 0f       	add	r30, r30
 256:	ff 1f       	adc	r31, r31
 258:	ea 59       	subi	r30, 0x9A	; 154
 25a:	ff 4f       	sbci	r31, 0xFF	; 255

0000025c <.Loc.152>:

	max5825_set_load_channel(dac_pos, dac_val);
 25c:	60 81       	ld	r22, Z
 25e:	71 81       	ldd	r23, Z+1	; 0x01

00000260 <.LVL44>:
 260:	8c 2f       	mov	r24, r28
 262:	97 d1       	rcall	.+814    	; 0x592 <max5825_set_load_channel>

00000264 <.LVL45>:
	(*set_pin_ptr)(dac_pos);
 264:	e0 91 63 00 	lds	r30, 0x0063	; 0x800063 <set_pin_ptr>
 268:	f0 91 64 00 	lds	r31, 0x0064	; 0x800064 <set_pin_ptr+0x1>
 26c:	8c 2f       	mov	r24, r28
 26e:	09 95       	icall

00000270 <.LVL46>:

	midi_note_cnt++;
 270:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <midi_note_cnt>
 274:	8f 5f       	subi	r24, 0xFF	; 255
 276:	80 93 e6 00 	sts	0x00E6, r24	; 0x8000e6 <midi_note_cnt>

0000027a <.L40>:
	return;
}
 27a:	cf 91       	pop	r28
 27c:	08 95       	ret

0000027e <tram8_init>:
	(*clear_pin_ptr)(PIN_A);
 27e:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 282:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 286:	80 e0       	ldi	r24, 0x00	; 0
 288:	09 95       	icall

0000028a <.LVL48>:
	(*clear_pin_ptr)(PIN_B);
 28a:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 28e:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	09 95       	icall

00000296 <.LVL49>:
	(*clear_pin_ptr)(PIN_C);
 296:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 29a:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 29e:	82 e0       	ldi	r24, 0x02	; 2
 2a0:	09 95       	icall

000002a2 <.LVL50>:
	(*clear_pin_ptr)(PIN_D);
 2a2:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 2a6:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 2aa:	83 e0       	ldi	r24, 0x03	; 3
 2ac:	09 95       	icall

000002ae <.LVL51>:
	(*clear_pin_ptr)(PIN_E);
 2ae:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 2b2:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 2b6:	84 e0       	ldi	r24, 0x04	; 4
 2b8:	09 95       	icall

000002ba <.LVL52>:
	(*clear_pin_ptr)(PIN_F);
 2ba:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 2be:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 2c2:	85 e0       	ldi	r24, 0x05	; 5
 2c4:	09 95       	icall

000002c6 <.LVL53>:
	(*clear_pin_ptr)(PIN_H);
 2c6:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 2ca:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 2ce:	87 e0       	ldi	r24, 0x07	; 7
 2d0:	09 95       	icall

000002d2 <.LVL54>:
	(*clear_pin_ptr)(PIN_G);
 2d2:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 2d6:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 2da:	86 e0       	ldi	r24, 0x06	; 6
 2dc:	09 95       	icall

000002de <.LBB21>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2de:	2f ef       	ldi	r18, 0xFF	; 255
 2e0:	89 e6       	ldi	r24, 0x69	; 105
 2e2:	98 e1       	ldi	r25, 0x18	; 24

000002e4 <.L1^B1>:
 2e4:	21 50       	subi	r18, 0x01	; 1
 2e6:	80 40       	sbci	r24, 0x00	; 0
 2e8:	90 40       	sbci	r25, 0x00	; 0
 2ea:	e1 f7       	brne	.-8      	; 0x2e4 <.L1^B1>
 2ec:	00 c0       	rjmp	.+0      	; 0x2ee <L0^A>

000002ee <L0^A>:
	...

000002f0 <.LBE24>:
}
 2f0:	08 95       	ret

000002f2 <__vector_6>:
{
 2f2:	1f 92       	push	r1
 2f4:	0f 92       	push	r0
 2f6:	0f b6       	in	r0, 0x3f	; 63
 2f8:	0f 92       	push	r0
 2fa:	11 24       	eor	r1, r1
 2fc:	2f 93       	push	r18
 2fe:	3f 93       	push	r19
 300:	4f 93       	push	r20
 302:	5f 93       	push	r21
 304:	6f 93       	push	r22
 306:	7f 93       	push	r23
 308:	8f 93       	push	r24
 30a:	9f 93       	push	r25
 30c:	af 93       	push	r26
 30e:	bf 93       	push	r27
 310:	ef 93       	push	r30
 312:	ff 93       	push	r31

00000314 <.Loc.198>:
	TCCR1B = 0;			  // stop timer
 314:	1e bc       	out	0x2e, r1	; 46

00000316 <.Loc.200>:
	TIFR |= (1 << OCF1A); // reset flag
 316:	88 b7       	in	r24, 0x38	; 56
 318:	80 61       	ori	r24, 0x10	; 16
 31a:	88 bf       	out	0x38, r24	; 56

0000031c <.Loc.202>:
	(*clear_pin_ptr)(PIN_A);
 31c:	e0 91 61 00 	lds	r30, 0x0061	; 0x800061 <clear_pin_ptr>
 320:	f0 91 62 00 	lds	r31, 0x0062	; 0x800062 <clear_pin_ptr+0x1>
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	09 95       	icall

00000328 <.LVL57>:
}
 328:	ff 91       	pop	r31
 32a:	ef 91       	pop	r30
 32c:	bf 91       	pop	r27
 32e:	af 91       	pop	r26
 330:	9f 91       	pop	r25
 332:	8f 91       	pop	r24
 334:	7f 91       	pop	r23
 336:	6f 91       	pop	r22
 338:	5f 91       	pop	r21
 33a:	4f 91       	pop	r20
 33c:	3f 91       	pop	r19
 33e:	2f 91       	pop	r18
 340:	0f 90       	pop	r0
 342:	0f be       	out	0x3f, r0	; 63
 344:	0f 90       	pop	r0
 346:	1f 90       	pop	r1
 348:	18 95       	reti

0000034a <__vector_11>:
{
 34a:	1f 92       	push	r1
 34c:	0f 92       	push	r0
 34e:	0f b6       	in	r0, 0x3f	; 63
 350:	0f 92       	push	r0
 352:	11 24       	eor	r1, r1
 354:	2f 93       	push	r18
 356:	3f 93       	push	r19
 358:	4f 93       	push	r20
 35a:	5f 93       	push	r21
 35c:	6f 93       	push	r22
 35e:	7f 93       	push	r23
 360:	8f 93       	push	r24
 362:	9f 93       	push	r25
 364:	af 93       	push	r26
 366:	bf 93       	push	r27
 368:	ef 93       	push	r30
 36a:	ff 93       	push	r31

0000036c <.Loc.206>:
	uint8_t byte = UDR;
 36c:	8c b1       	in	r24, 0x0c	; 12

0000036e <.LVL58>:
	midi_receive_byte(byte);
 36e:	4d d1       	rcall	.+666    	; 0x60a <midi_receive_byte>

00000370 <.LVL59>:
}
 370:	ff 91       	pop	r31
 372:	ef 91       	pop	r30
 374:	bf 91       	pop	r27
 376:	af 91       	pop	r26
 378:	9f 91       	pop	r25
 37a:	8f 91       	pop	r24
 37c:	7f 91       	pop	r23
 37e:	6f 91       	pop	r22
 380:	5f 91       	pop	r21
 382:	4f 91       	pop	r20
 384:	3f 91       	pop	r19
 386:	2f 91       	pop	r18
 388:	0f 90       	pop	r0
 38a:	0f be       	out	0x3f, r0	; 63
 38c:	0f 90       	pop	r0
 38e:	1f 90       	pop	r1
 390:	18 95       	reti

00000392 <set_LED>:
	if (var == ENABLE)
 392:	81 30       	cpi	r24, 0x01	; 1
 394:	11 f0       	breq	.+4      	; 0x39a <.L57>

00000396 <.Loc.229>:
		DDRC &= 0xFF ^ (1 << LED_pin);
 396:	a0 98       	cbi	0x14, 0	; 20

00000398 <.Loc.231>:
}
 398:	08 95       	ret

0000039a <.L57>:
		DDRC |= (1 << LED_pin);
 39a:	a0 9a       	sbi	0x14, 0	; 20
 39c:	08 95       	ret

0000039e <tram8_cfg>:
	DDRC = 0x0C | (1 << LED_pin) | (1 << BUTTON_PIN); // LDAC & CLEAR & LED
 39e:	8f e0       	ldi	r24, 0x0F	; 15
 3a0:	84 bb       	out	0x14, r24	; 20

000003a2 <.Loc.238>:
	DDRB |= (1 << PB0);								  // Trigger Out 0
 3a2:	b8 9a       	sbi	0x17, 0	; 23

000003a4 <.Loc.240>:
	DDRD |= 0xFE;									  // Trigger outs 1-7
 3a4:	81 b3       	in	r24, 0x11	; 17
 3a6:	8e 6f       	ori	r24, 0xFE	; 254
 3a8:	81 bb       	out	0x11, r24	; 17

000003aa <.Loc.242>:
	PORTD &= 0x01; // ALL GATES LOW (Inverter Out)
 3aa:	82 b3       	in	r24, 0x12	; 18
 3ac:	81 70       	andi	r24, 0x01	; 1
 3ae:	82 bb       	out	0x12, r24	; 18

000003b0 <.Loc.244>:
	PORTB &= 0xFE; //
 3b0:	c0 98       	cbi	0x18, 0	; 24

000003b2 <.Loc.246>:
	set_LED(ENABLE);
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	ee df       	rcall	.-36     	; 0x392 <set_LED>

000003b6 <.LBB25>:
 3b6:	2f ef       	ldi	r18, 0xFF	; 255
 3b8:	85 ea       	ldi	r24, 0xA5	; 165
 3ba:	9e e0       	ldi	r25, 0x0E	; 14

000003bc <.L1^B2>:
 3bc:	21 50       	subi	r18, 0x01	; 1
 3be:	80 40       	sbci	r24, 0x00	; 0
 3c0:	90 40       	sbci	r25, 0x00	; 0
 3c2:	e1 f7       	brne	.-8      	; 0x3bc <.L1^B2>
 3c4:	00 c0       	rjmp	.+0      	; 0x3c6 <L0^A>

000003c6 <L0^A>:
	...

000003c8 <.LBE28>:
	set_LED(DISABLE);
 3c8:	80 e0       	ldi	r24, 0x00	; 0
 3ca:	e3 df       	rcall	.-58     	; 0x392 <set_LED>

000003cc <.L59>:
	} while (!eeprom_is_ready());
 3cc:	e1 99       	sbic	0x1c, 1	; 28
 3ce:	fe cf       	rjmp	.-4      	; 0x3cc <.L59>

000003d0 <.Loc.264>:
	buttonfix_flag = eeprom_read_byte(BUTTONFIXVARIABLE);
 3d0:	87 e0       	ldi	r24, 0x07	; 7
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	db d3       	rcall	.+1974   	; 0xb8c <eeprom_read_byte>

000003d6 <.LVL66>:
	if (buttonfix_flag == 0xAA)
 3d6:	8a 3a       	cpi	r24, 0xAA	; 170
 3d8:	79 f1       	breq	.+94     	; 0x438 <.L70>

000003da <.L60>:
	TCCR2 = (1 << WGM20) | (0 << WGM21) | (0b111 << CS20); // CTC, PORT disconnected, /1024
 3da:	87 e4       	ldi	r24, 0x47	; 71

000003dc <.LVL67>:
 3dc:	85 bd       	out	0x25, r24	; 37

000003de <.Loc.271>:
	OCR2 = 157;											   // ca. 10ms@16MHz
 3de:	8d e9       	ldi	r24, 0x9D	; 157
 3e0:	83 bd       	out	0x23, r24	; 35

000003e2 <.Loc.273>:
	UCSRB = (1 << RXCIE) | (1 << RXEN);
 3e2:	80 e9       	ldi	r24, 0x90	; 144
 3e4:	8a b9       	out	0x0a, r24	; 10

000003e6 <.Loc.275>:
	UCSRC = (1 << UCSZ0) | (1 << UCSZ1);
 3e6:	86 e0       	ldi	r24, 0x06	; 6
 3e8:	80 bd       	out	0x20, r24	; 32

000003ea <.Loc.277>:
	UBRRH = (unsigned char)(MYUBRR >> 8);
 3ea:	10 bc       	out	0x20, r1	; 32

000003ec <.Loc.279>:
	UBRRL = (unsigned char)MYUBRR;
 3ec:	8f e1       	ldi	r24, 0x1F	; 31
 3ee:	89 b9       	out	0x09, r24	; 9

000003f0 <.L61>:
	} while (!eeprom_is_ready());
 3f0:	e1 99       	sbic	0x1c, 1	; 28
 3f2:	fe cf       	rjmp	.-4      	; 0x3f0 <.L61>

000003f4 <.L62>:
	} while (!eeprom_is_ready());
 3f4:	e1 99       	sbic	0x1c, 1	; 28
 3f6:	fe cf       	rjmp	.-4      	; 0x3f4 <.L62>

000003f8 <.L63>:
	} while (!eeprom_is_ready());
 3f8:	e1 99       	sbic	0x1c, 1	; 28
 3fa:	fe cf       	rjmp	.-4      	; 0x3f8 <.L63>

000003fc <.Loc.293>:
	PORTC = (1 << PC2) | (1 << PC3);
 3fc:	8c e0       	ldi	r24, 0x0C	; 12
 3fe:	85 bb       	out	0x15, r24	; 21

00000400 <.Loc.295>:
	DDRC |= (1 << PC2) | (1 << PC3);
 400:	84 b3       	in	r24, 0x14	; 20
 402:	8c 60       	ori	r24, 0x0C	; 12
 404:	84 bb       	out	0x14, r24	; 20

00000406 <.Loc.297>:
	init_max5825();
 406:	ab d0       	rcall	.+342    	; 0x55e <init_max5825>

00000408 <.LBB29>:
 408:	2f ef       	ldi	r18, 0xFF	; 255
 40a:	81 ee       	ldi	r24, 0xE1	; 225
 40c:	94 e0       	ldi	r25, 0x04	; 4

0000040e <.L1^B3>:
 40e:	21 50       	subi	r18, 0x01	; 1
 410:	80 40       	sbci	r24, 0x00	; 0
 412:	90 40       	sbci	r25, 0x00	; 0
 414:	e1 f7       	brne	.-8      	; 0x40e <.L1^B3>
 416:	00 c0       	rjmp	.+0      	; 0x418 <L0^A>

00000418 <L0^A>:
	...

0000041a <.LBE32>:
	if ((PINB >> PB1) & 1)
 41a:	b1 9b       	sbis	0x16, 1	; 22
 41c:	0f c0       	rjmp	.+30     	; 0x43c <.L64>

0000041e <.Loc.311>:
		set_pin_ptr = &set_pin_inv;
 41e:	8e e7       	ldi	r24, 0x7E	; 126
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	90 93 64 00 	sts	0x0064, r25	; 0x800064 <set_pin_ptr+0x1>
 426:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <set_pin_ptr>

0000042a <.Loc.313>:
		clear_pin_ptr = &clear_pin_inv;
 42a:	85 e9       	ldi	r24, 0x95	; 149
 42c:	90 e0       	ldi	r25, 0x00	; 0
 42e:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <clear_pin_ptr+0x1>
 432:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <clear_pin_ptr>
 436:	08 95       	ret

00000438 <.L70>:
		DDRC &= ~((1 << BUTTON_PIN)); // INPUT
 438:	a1 98       	cbi	0x14, 1	; 20
 43a:	cf cf       	rjmp	.-98     	; 0x3da <.L60>

0000043c <.L64>:
		set_pin_ptr = &clear_pin_inv;
 43c:	85 e9       	ldi	r24, 0x95	; 149
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	90 93 64 00 	sts	0x0064, r25	; 0x800064 <set_pin_ptr+0x1>
 444:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <set_pin_ptr>

00000448 <.Loc.319>:
		clear_pin_ptr = &set_pin_inv;
 448:	8e e7       	ldi	r24, 0x7E	; 126
 44a:	90 e0       	ldi	r25, 0x00	; 0
 44c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <clear_pin_ptr+0x1>
 450:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <clear_pin_ptr>

00000454 <.Loc.321>:
}
 454:	08 95       	ret

00000456 <start_timer1>:
	TCNT1 = 0;
 456:	1d bc       	out	0x2d, r1	; 45
 458:	1c bc       	out	0x2c, r1	; 44

0000045a <.Loc.325>:
	TCCR1A = 0;
 45a:	1f bc       	out	0x2f, r1	; 47

0000045c <.Loc.327>:
	TCCR1B = (0b101 << CS00); /// 1024
 45c:	95 e0       	ldi	r25, 0x05	; 5
 45e:	9e bd       	out	0x2e, r25	; 46

00000460 <.Loc.329>:
	OCR1A = cmp_value;		  // 157;//ca. 10ms@16MHz
 460:	90 e0       	ldi	r25, 0x00	; 0
 462:	9b bd       	out	0x2b, r25	; 43
 464:	8a bd       	out	0x2a, r24	; 42

00000466 <.Loc.331>:
	TIFR |= (1 << OCF1A);
 466:	88 b7       	in	r24, 0x38	; 56

00000468 <.LVL73>:
 468:	80 61       	ori	r24, 0x10	; 16
 46a:	88 bf       	out	0x38, r24	; 56

0000046c <.Loc.334>:
	TIMSK |= (1 << OCIE1A);
 46c:	89 b7       	in	r24, 0x39	; 57
 46e:	80 61       	ori	r24, 0x10	; 16
 470:	89 bf       	out	0x39, r24	; 57

00000472 <.Loc.336>:
}
 472:	08 95       	ret

00000474 <clock>:
	if (midi_clock_run && midi_clock_tick_cntr % 6 == 0)
 474:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <midi_clock_run>

00000478 <.LVL75>:
 478:	88 23       	and	r24, r24
 47a:	b1 f0       	breq	.+44     	; 0x4a8 <.L73>

0000047c <.Loc.342>:
 47c:	20 91 e9 00 	lds	r18, 0x00E9	; 0x8000e9 <midi_clock_tick_cntr>
 480:	8b ea       	ldi	r24, 0xAB	; 171
 482:	28 9f       	mul	r18, r24
 484:	81 2d       	mov	r24, r1
 486:	11 24       	eor	r1, r1
 488:	86 95       	lsr	r24
 48a:	86 95       	lsr	r24
 48c:	98 2f       	mov	r25, r24
 48e:	99 0f       	add	r25, r25
 490:	89 0f       	add	r24, r25
 492:	88 0f       	add	r24, r24

00000494 <.Loc.343>:
 494:	28 13       	cpse	r18, r24
 496:	08 c0       	rjmp	.+16     	; 0x4a8 <.L73>

00000498 <.Loc.344>:
		(*set_pin_ptr)(PIN_A);
 498:	e0 91 63 00 	lds	r30, 0x0063	; 0x800063 <set_pin_ptr>
 49c:	f0 91 64 00 	lds	r31, 0x0064	; 0x800064 <set_pin_ptr+0x1>
 4a0:	80 e0       	ldi	r24, 0x00	; 0
 4a2:	09 95       	icall

000004a4 <.LVL76>:
		start_timer1(78); // enable clock timer to trigger pin reset
 4a4:	8e e4       	ldi	r24, 0x4E	; 78
 4a6:	d7 df       	rcall	.-82     	; 0x456 <start_timer1>

000004a8 <.L73>:
	midi_clock_tick_cntr++;
 4a8:	80 91 e9 00 	lds	r24, 0x00E9	; 0x8000e9 <midi_clock_tick_cntr>
 4ac:	8f 5f       	subi	r24, 0xFF	; 255

000004ae <.Loc.349>:
	if (midi_clock_tick_cntr > 23)  // reset
 4ae:	88 31       	cpi	r24, 0x18	; 24
 4b0:	18 f4       	brcc	.+6      	; 0x4b8 <.L74>

000004b2 <.Loc.351>:
	midi_clock_tick_cntr++;
 4b2:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <midi_clock_tick_cntr>
 4b6:	08 95       	ret

000004b8 <.L74>:
		midi_clock_tick_cntr = 0;
 4b8:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <midi_clock_tick_cntr>

000004bc <.Loc.354>:
}
 4bc:	08 95       	ret

000004be <register_funcs>:

void register_funcs(void)
{
	midi_register_event_handler(EVT_SYS_REALTIME_TIMING_CLOCK, clock);
 4be:	6a e3       	ldi	r22, 0x3A	; 58
 4c0:	72 e0       	ldi	r23, 0x02	; 2
 4c2:	80 e0       	ldi	r24, 0x00	; 0
 4c4:	8a d0       	rcall	.+276    	; 0x5da <midi_register_event_handler>

000004c6 <.LVL78>:
	midi_register_event_handler(EVT_SYS_REALTIME_SEQ_START, run);
 4c6:	6b ed       	ldi	r22, 0xDB	; 219
 4c8:	70 e0       	ldi	r23, 0x00	; 0
 4ca:	82 e0       	ldi	r24, 0x02	; 2
 4cc:	86 d0       	rcall	.+268    	; 0x5da <midi_register_event_handler>

000004ce <.LVL79>:
	midi_register_event_handler(EVT_SYS_REALTIME_SEQ_STOP, stop);
 4ce:	63 ef       	ldi	r22, 0xF3	; 243
 4d0:	70 e0       	ldi	r23, 0x00	; 0
 4d2:	84 e0       	ldi	r24, 0x04	; 4
 4d4:	82 d0       	rcall	.+260    	; 0x5da <midi_register_event_handler>

000004d6 <.LVL80>:
	midi_register_event_handler(EVT_SYS_REALTIME_SEQ_CONTINUE, cont);
 4d6:	68 ee       	ldi	r22, 0xE8	; 232
 4d8:	70 e0       	ldi	r23, 0x00	; 0
 4da:	83 e0       	ldi	r24, 0x03	; 3
 4dc:	7e d0       	rcall	.+252    	; 0x5da <midi_register_event_handler>

000004de <.LVL81>:
	midi_register_event_handler(EVT_CHAN_NOTE_ON, note_on);
 4de:	6f ef       	ldi	r22, 0xFF	; 255
 4e0:	70 e0       	ldi	r23, 0x00	; 0
 4e2:	89 e0       	ldi	r24, 0x09	; 9
 4e4:	7a d0       	rcall	.+244    	; 0x5da <midi_register_event_handler>

000004e6 <.LVL82>:
	midi_register_event_handler(EVT_CHAN_NOTE_OFF, note_off);
 4e6:	6c ea       	ldi	r22, 0xAC	; 172
 4e8:	70 e0       	ldi	r23, 0x00	; 0
 4ea:	88 e0       	ldi	r24, 0x08	; 8
 4ec:	76 d0       	rcall	.+236    	; 0x5da <midi_register_event_handler>

000004ee <.LVL83>:
 4ee:	08 95       	ret

000004f0 <main>:
	tram8_cfg();
 4f0:	56 df       	rcall	.-340    	; 0x39e <tram8_cfg>

000004f2 <.LVL84>:
	tram8_init();
 4f2:	c5 de       	rcall	.-630    	; 0x27e <tram8_init>

000004f4 <.LVL85>:
	midi_init();
 4f4:	65 d0       	rcall	.+202    	; 0x5c0 <midi_init>

000004f6 <.LVL86>:
	register_funcs();
 4f6:	e3 df       	rcall	.-58     	; 0x4be <register_funcs>

000004f8 <.LVL87>:
	sei();
 4f8:	78 94       	sei

000004fa <.LBB33>:
			learn_button = BUTTON_DOWN;
 4fa:	c2 e0       	ldi	r28, 0x02	; 2

000004fc <.Loc.371>:
						learn_button = BUTTON_PRESSED;
 4fc:	13 e0       	ldi	r17, 0x03	; 3

000004fe <.Loc.372>:
						learn_button = BUTTON_RELEASED;
 4fe:	d4 e0       	ldi	r29, 0x04	; 4
 500:	08 c0       	rjmp	.+16     	; 0x512 <.L83>

00000502 <.L90>:
			set_LED(DISABLE);
 502:	80 e0       	ldi	r24, 0x00	; 0
 504:	46 df       	rcall	.-372    	; 0x392 <set_LED>

00000506 <.LVL88>:
		if (learn_button == BUTTON_DOWN)
 506:	02 c0       	rjmp	.+4      	; 0x50c <.L80>

00000508 <.L81>:
 508:	82 30       	cpi	r24, 0x02	; 2
 50a:	59 f0       	breq	.+22     	; 0x522 <.L82>

0000050c <.L80>:
		if ((TIFR >> OCF2) & 1) // Timer Interrupt Flag Register
 50c:	08 b6       	in	r0, 0x38	; 56
 50e:	07 fc       	sbrc	r0, 7
 510:	0b c0       	rjmp	.+22     	; 0x528 <.L89>

00000512 <.L83>:
		if ((learn_button == BUTTON_RELEASED))
 512:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <learn_button.2369>

00000516 <.Loc.388>:
 516:	84 30       	cpi	r24, 0x04	; 4
 518:	a1 f3       	breq	.-24     	; 0x502 <.L90>

0000051a <.Loc.389>:
		if (learn_button == BUTTON_PRESSED)
 51a:	83 30       	cpi	r24, 0x03	; 3
 51c:	a9 f7       	brne	.-22     	; 0x508 <.L81>

0000051e <.Loc.391>:
			learn_button = BUTTON_DOWN;
 51e:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <learn_button.2369>

00000522 <.L82>:
			set_LED(ENABLE);
 522:	81 e0       	ldi	r24, 0x01	; 1
 524:	36 df       	rcall	.-404    	; 0x392 <set_LED>

00000526 <.LVL89>:
 526:	f2 cf       	rjmp	.-28     	; 0x50c <.L80>

00000528 <.L89>:
			TCNT2 = 0;			 // reset timer
 528:	14 bc       	out	0x24, r1	; 36

0000052a <.Loc.397>:
			TIFR |= (1 << OCF2); // reset flag
 52a:	88 b7       	in	r24, 0x38	; 56
 52c:	80 68       	ori	r24, 0x80	; 128
 52e:	88 bf       	out	0x38, r24	; 56

00000530 <.Loc.399>:
			button_now = PINC & (1 << BUTTON_PIN);
 530:	83 b3       	in	r24, 0x13	; 19
 532:	82 70       	andi	r24, 0x02	; 2

00000534 <.Loc.401>:
			if (button_now != button_bounce)
 534:	90 91 df 00 	lds	r25, 0x00DF	; 0x8000df <button_bounce.2371>
 538:	89 17       	cp	r24, r25
 53a:	19 f0       	breq	.+6      	; 0x542 <.L84>

0000053c <.Loc.403>:
				button_bounce = button_now;
 53c:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <button_bounce.2371>
 540:	e8 cf       	rjmp	.-48     	; 0x512 <.L83>

00000542 <.L84>:
				if (button_now != button_last)
 542:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <button_last.2372>
 546:	89 17       	cp	r24, r25
 548:	21 f3       	breq	.-56     	; 0x512 <.L83>

0000054a <.Loc.407>:
					if (button_now == 0)
 54a:	81 11       	cpse	r24, r1
 54c:	05 c0       	rjmp	.+10     	; 0x558 <.L86>

0000054e <.Loc.409>:
						learn_button = BUTTON_RELEASED;
 54e:	d0 93 60 00 	sts	0x0060, r29	; 0x800060 <learn_button.2369>

00000552 <.L87>:
					button_last = button_now;
 552:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <button_last.2372>
 556:	dd cf       	rjmp	.-70     	; 0x512 <.L83>

00000558 <.L86>:
						learn_button = BUTTON_PRESSED;
 558:	10 93 60 00 	sts	0x0060, r17	; 0x800060 <learn_button.2369>
 55c:	fa cf       	rjmp	.-12     	; 0x552 <.L87>

0000055e <init_max5825>:

#include <avr/io.h>
#include "MAX5825.h"
#include "general_twi.h"

void init_max5825(void){
 55e:	cf 93       	push	r28
 560:	df 93       	push	r29
 562:	00 d0       	rcall	.+0      	; 0x564 <L0^A>

00000564 <L0^A>:
 564:	cd b7       	in	r28, 0x3d	; 61
 566:	de b7       	in	r29, 0x3e	; 62

00000568 <.Loc.1>:
		
	

	uint8_t data[2] = {NULL};
 568:	1a 82       	std	Y+2, r1	; 0x02
 56a:	19 82       	std	Y+1, r1	; 0x01

0000056c <.Loc.3>:
	TWI_WRITE_BULK(MAX5825_ADDR,(MAX5825_REG_REF | 0b101),2,&data); //INT REF 0b111=4.096V //0b101=2.5V ALL DAC PWR ON 	
 56c:	9e 01       	movw	r18, r28
 56e:	2f 5f       	subi	r18, 0xFF	; 255
 570:	3f 4f       	sbci	r19, 0xFF	; 255
 572:	42 e0       	ldi	r20, 0x02	; 2
 574:	65 e2       	ldi	r22, 0x25	; 37
 576:	80 e2       	ldi	r24, 0x20	; 32
 578:	72 dd       	rcall	.-1308   	; 0x5e <TWI_WRITE_BULK>

0000057a <.LVL0>:
		
	TWI_WRITE_BULK(MAX5825_ADDR,MAX5825_REG_CODELOADALL,2,&data); // all to zero 
 57a:	9e 01       	movw	r18, r28
 57c:	2f 5f       	subi	r18, 0xFF	; 255
 57e:	3f 4f       	sbci	r19, 0xFF	; 255
 580:	42 e0       	ldi	r20, 0x02	; 2
 582:	62 ec       	ldi	r22, 0xC2	; 194
 584:	80 e2       	ldi	r24, 0x20	; 32
 586:	6b dd       	rcall	.-1322   	; 0x5e <TWI_WRITE_BULK>

00000588 <.LVL1>:
		
	
	return;
}
 588:	0f 90       	pop	r0
 58a:	0f 90       	pop	r0
 58c:	df 91       	pop	r29
 58e:	cf 91       	pop	r28
 590:	08 95       	ret

00000592 <max5825_set_load_channel>:
	
	return retval;
}


void max5825_set_load_channel(uint8_t ch, uint16_t value){
 592:	cf 93       	push	r28
 594:	df 93       	push	r29
 596:	00 d0       	rcall	.+0      	; 0x598 <L0^A>

00000598 <L0^A>:
 598:	cd b7       	in	r28, 0x3d	; 61
 59a:	de b7       	in	r29, 0x3e	; 62

0000059c <.LVL5>:
	
	uint8_t cmd_addr = (MAX5825_REG_CODEn_LOADn | (ch & 0x0F));
	uint8_t data[2];
	
	data[0]= (uint8_t) ((value>>8) & 0xFF);
 59c:	79 83       	std	Y+1, r23	; 0x01

0000059e <.Loc.21>:
	data[1]= (uint8_t) (value & 0xF0);
 59e:	60 7f       	andi	r22, 0xF0	; 240

000005a0 <.LVL6>:
 5a0:	6a 83       	std	Y+2, r22	; 0x02

000005a2 <.Loc.24>:
	uint8_t cmd_addr = (MAX5825_REG_CODEn_LOADn | (ch & 0x0F));
 5a2:	68 2f       	mov	r22, r24
 5a4:	6f 70       	andi	r22, 0x0F	; 15

000005a6 <.Loc.26>:
 5a6:	60 6b       	ori	r22, 0xB0	; 176

000005a8 <.LVL7>:

	TWI_WRITE_BULK(MAX5825_ADDR,cmd_addr,2,&data);
 5a8:	9e 01       	movw	r18, r28
 5aa:	2f 5f       	subi	r18, 0xFF	; 255
 5ac:	3f 4f       	sbci	r19, 0xFF	; 255
 5ae:	42 e0       	ldi	r20, 0x02	; 2
 5b0:	80 e2       	ldi	r24, 0x20	; 32

000005b2 <.LVL8>:
 5b2:	55 dd       	rcall	.-1366   	; 0x5e <TWI_WRITE_BULK>

000005b4 <.LVL9>:
	
	return;
}
 5b4:	0f 90       	pop	r0
 5b6:	0f 90       	pop	r0
 5b8:	df 91       	pop	r29
 5ba:	cf 91       	pop	r28
 5bc:	08 95       	ret

000005be <null_event_cb>:

// The null event callback is used by default for all events.
static void null_event_cb(char channel, char a, char b) {
  // Do nothing. The invoke_callback() function will properly implement the
  // global message counter.
}
 5be:	08 95       	ret

000005c0 <midi_init>:
 ****************************************************************************/


status_t midi_init() {
    // Initialize the callback table; all events to the null callback.
    for (int i = 0; i < EVT_MAX; ++i) {
 5c0:	ea ee       	ldi	r30, 0xEA	; 234
 5c2:	f0 e0       	ldi	r31, 0x00	; 0
 5c4:	28 e0       	ldi	r18, 0x08	; 8
 5c6:	31 e0       	ldi	r19, 0x01	; 1

000005c8 <.Loc.6>:
        g_callbacks[i] = null_event_cb;
 5c8:	8f ed       	ldi	r24, 0xDF	; 223
 5ca:	92 e0       	ldi	r25, 0x02	; 2

000005cc <.L3>:
 5cc:	81 93       	st	Z+, r24
 5ce:	91 93       	st	Z+, r25

000005d0 <.Loc.10>:
    for (int i = 0; i < EVT_MAX; ++i) {
 5d0:	e2 17       	cp	r30, r18
 5d2:	f3 07       	cpc	r31, r19
 5d4:	d9 f7       	brne	.-10     	; 0x5cc <.L3>

000005d6 <.LBE2>:
    }
    return 0;
}
 5d6:	80 e0       	ldi	r24, 0x00	; 0
 5d8:	08 95       	ret

000005da <midi_register_event_handler>:


status_t midi_register_event_handler(event_type evt, midi_event_callback_t cb) {
 5da:	e8 2f       	mov	r30, r24
 5dc:	86 2f       	mov	r24, r22

000005de <.LVL4>:
 5de:	97 2f       	mov	r25, r23

000005e0 <.Loc.17>:
    if (cb) {
 5e0:	00 97       	sbiw	r24, 0x00	; 0
 5e2:	49 f0       	breq	.+18     	; 0x5f6 <.L6>

000005e4 <.Loc.19>:
        g_callbacks[evt] = cb;
 5e4:	f0 e0       	ldi	r31, 0x00	; 0

000005e6 <.Loc.21>:
 5e6:	ee 0f       	add	r30, r30
 5e8:	ff 1f       	adc	r31, r31

000005ea <.LVL5>:
 5ea:	e6 51       	subi	r30, 0x16	; 22
 5ec:	ff 4f       	sbci	r31, 0xFF	; 255
 5ee:	91 83       	std	Z+1, r25	; 0x01
 5f0:	80 83       	st	Z, r24

000005f2 <.L7>:
    } else {
        g_callbacks[evt] = null_event_cb;
    }
    
    return 0;    
}
 5f2:	80 e0       	ldi	r24, 0x00	; 0
 5f4:	08 95       	ret

000005f6 <.L6>:
        g_callbacks[evt] = null_event_cb;
 5f6:	f0 e0       	ldi	r31, 0x00	; 0

000005f8 <.Loc.27>:
 5f8:	ee 0f       	add	r30, r30
 5fa:	ff 1f       	adc	r31, r31

000005fc <.LVL7>:
 5fc:	e6 51       	subi	r30, 0x16	; 22
 5fe:	ff 4f       	sbci	r31, 0xFF	; 255
 600:	8f ed       	ldi	r24, 0xDF	; 223
 602:	92 e0       	ldi	r25, 0x02	; 2
 604:	91 83       	std	Z+1, r25	; 0x01
 606:	80 83       	st	Z, r24
 608:	f4 cf       	rjmp	.-24     	; 0x5f2 <.L7>

0000060a <midi_receive_byte>:
     * 
     * If it is determined that the byte is not any type of status byte, then
     * by process of elimination, it must be a data byte.
     */
    
    if ((byte & SYS_REALTIME_MASK) == SYS_REALTIME_MASK) {
 60a:	98 2f       	mov	r25, r24
 60c:	98 7f       	andi	r25, 0xF8	; 248
 60e:	98 3f       	cpi	r25, 0xF8	; 248
 610:	91 f0       	breq	.+36     	; 0x636 <.L46>

00000612 <.Loc.32>:
        // The byte is a system real-time status byte.
        g_debug_last_status_byte = byte;
        return rx_status_sys_realtime_byte(byte);
    } else if ((byte & SYS_COMMON_MASK) == SYS_COMMON_MASK) {
 612:	98 2f       	mov	r25, r24
 614:	90 7f       	andi	r25, 0xF0	; 240

00000616 <.Loc.33>:
 616:	90 3f       	cpi	r25, 0xF0	; 240
 618:	09 f4       	brne	.+2      	; 0x61c <.Loc.34>

0000061a <L0^A>:
 61a:	b6 c2       	rjmp	.+1388   	; 0xb88 <.L45>

0000061c <.Loc.34>:
        // The byte is a system common status byte.
        g_debug_last_status_byte = byte;
        return rx_status_sys_common_byte(byte);
    } else if (byte & CHAN_STATUS_MASK) {
 61c:	88 23       	and	r24, r24
 61e:	0c f4       	brge	.+2      	; 0x622 <.LBB41>

00000620 <L0^A>:
 620:	33 c1       	rjmp	.+614    	; 0x888 <.L47>

00000622 <.LBB41>:
    switch (g_state) {
 622:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <g_state>
 626:	e2 50       	subi	r30, 0x02	; 2
 628:	ec 30       	cpi	r30, 0x0C	; 12
 62a:	08 f0       	brcs	.+2      	; 0x62e <L0^A+0x2>

0000062c <L0^A>:
 62c:	a5 c2       	rjmp	.+1354   	; 0xb78 <.L30>
 62e:	f0 e0       	ldi	r31, 0x00	; 0
 630:	e0 52       	subi	r30, 0x20	; 32
 632:	fa 4f       	sbci	r31, 0xFA	; 250
 634:	09 94       	ijmp

00000636 <.L46>:
    switch (byte) {
 636:	88 5f       	subi	r24, 0xF8	; 248

00000638 <.LVL11>:
 638:	88 30       	cpi	r24, 0x08	; 8
 63a:	08 f0       	brcs	.+2      	; 0x63e <L0^A+0x2>

0000063c <L0^A>:
 63c:	a3 c2       	rjmp	.+1350   	; 0xb84 <.L44>
 63e:	e8 2f       	mov	r30, r24
 640:	f0 e0       	ldi	r31, 0x00	; 0
 642:	e4 51       	subi	r30, 0x14	; 20
 644:	fa 4f       	sbci	r31, 0xFA	; 250
 646:	09 94       	ijmp

00000648 <.L19>:
    ++g_message_counter;
 648:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 64c:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 650:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 654:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>

00000658 <.LVL13>:
 658:	01 96       	adiw	r24, 0x01	; 1
 65a:	a1 1d       	adc	r26, r1
 65c:	b1 1d       	adc	r27, r1
 65e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 662:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 666:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 66a:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

0000066e <.Loc.51>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 66e:	e0 91 ea 00 	lds	r30, 0x00EA	; 0x8000ea <g_callbacks>
 672:	f0 91 eb 00 	lds	r31, 0x00EB	; 0x8000eb <g_callbacks+0x1>
 676:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 67a:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 67e:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 682:	09 95       	icall

00000684 <.Loc.53>:
    g_data_byte_one = 0;
 684:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000688 <.Loc.55>:
    g_data_byte_two = 0;
 688:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

0000068c <.LBE59>:
        return rx_status_sys_realtime_byte(byte);
 68c:	81 e0       	ldi	r24, 0x01	; 1
 68e:	08 95       	ret

00000690 <.L18>:
    ++g_message_counter;
 690:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 694:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 698:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 69c:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 6a0:	01 96       	adiw	r24, 0x01	; 1
 6a2:	a1 1d       	adc	r26, r1
 6a4:	b1 1d       	adc	r27, r1
 6a6:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 6aa:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 6ae:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 6b2:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

000006b6 <.Loc.62>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 6b6:	e0 91 ec 00 	lds	r30, 0x00EC	; 0x8000ec <g_callbacks+0x2>
 6ba:	f0 91 ed 00 	lds	r31, 0x00ED	; 0x8000ed <g_callbacks+0x3>
 6be:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 6c2:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 6c6:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 6ca:	09 95       	icall

000006cc <.Loc.64>:
    g_data_byte_one = 0;
 6cc:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

000006d0 <.Loc.66>:
    g_data_byte_two = 0;
 6d0:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

000006d4 <.LBE61>:
        return rx_status_sys_realtime_byte(byte);
 6d4:	81 e0       	ldi	r24, 0x01	; 1
 6d6:	08 95       	ret

000006d8 <.L17>:
    ++g_message_counter;
 6d8:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 6dc:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 6e0:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 6e4:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 6e8:	01 96       	adiw	r24, 0x01	; 1
 6ea:	a1 1d       	adc	r26, r1
 6ec:	b1 1d       	adc	r27, r1
 6ee:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 6f2:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 6f6:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 6fa:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

000006fe <.Loc.73>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 6fe:	e0 91 ee 00 	lds	r30, 0x00EE	; 0x8000ee <g_callbacks+0x4>
 702:	f0 91 ef 00 	lds	r31, 0x00EF	; 0x8000ef <g_callbacks+0x5>
 706:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 70a:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 70e:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 712:	09 95       	icall

00000714 <.Loc.75>:
    g_data_byte_one = 0;
 714:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000718 <.Loc.77>:
    g_data_byte_two = 0;
 718:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

0000071c <.LBE63>:
        return rx_status_sys_realtime_byte(byte);
 71c:	81 e0       	ldi	r24, 0x01	; 1
 71e:	08 95       	ret

00000720 <.L16>:
    ++g_message_counter;
 720:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 724:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 728:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 72c:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 730:	01 96       	adiw	r24, 0x01	; 1
 732:	a1 1d       	adc	r26, r1
 734:	b1 1d       	adc	r27, r1
 736:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 73a:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 73e:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 742:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

00000746 <.Loc.84>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 746:	e0 91 f0 00 	lds	r30, 0x00F0	; 0x8000f0 <g_callbacks+0x6>
 74a:	f0 91 f1 00 	lds	r31, 0x00F1	; 0x8000f1 <g_callbacks+0x7>
 74e:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 752:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 756:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 75a:	09 95       	icall

0000075c <.Loc.86>:
    g_data_byte_one = 0;
 75c:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000760 <.Loc.88>:
    g_data_byte_two = 0;
 760:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000764 <.LBE65>:
        return rx_status_sys_realtime_byte(byte);
 764:	81 e0       	ldi	r24, 0x01	; 1
 766:	08 95       	ret

00000768 <.L15>:
    ++g_message_counter;
 768:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 76c:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 770:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 774:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 778:	01 96       	adiw	r24, 0x01	; 1
 77a:	a1 1d       	adc	r26, r1
 77c:	b1 1d       	adc	r27, r1
 77e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 782:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 786:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 78a:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

0000078e <.Loc.95>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 78e:	e0 91 f2 00 	lds	r30, 0x00F2	; 0x8000f2 <g_callbacks+0x8>
 792:	f0 91 f3 00 	lds	r31, 0x00F3	; 0x8000f3 <g_callbacks+0x9>
 796:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 79a:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 79e:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 7a2:	09 95       	icall

000007a4 <.Loc.97>:
    g_data_byte_one = 0;
 7a4:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

000007a8 <.Loc.100>:
    g_data_byte_two = 0;
 7a8:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

000007ac <.LBE67>:
        return rx_status_sys_realtime_byte(byte);
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	08 95       	ret

000007b0 <.L14>:
    ++g_message_counter;
 7b0:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 7b4:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 7b8:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 7bc:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 7c0:	01 96       	adiw	r24, 0x01	; 1
 7c2:	a1 1d       	adc	r26, r1
 7c4:	b1 1d       	adc	r27, r1
 7c6:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 7ca:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 7ce:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 7d2:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

000007d6 <.Loc.106>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 7d6:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <g_callbacks+0xa>
 7da:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <g_callbacks+0xb>
 7de:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 7e2:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 7e6:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 7ea:	09 95       	icall

000007ec <.Loc.108>:
    g_data_byte_one = 0;
 7ec:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

000007f0 <.Loc.110>:
    g_data_byte_two = 0;
 7f0:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

000007f4 <.LBE69>:
        return rx_status_sys_realtime_byte(byte);
 7f4:	81 e0       	ldi	r24, 0x01	; 1
 7f6:	08 95       	ret

000007f8 <.L13>:
    ++g_message_counter;
 7f8:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 7fc:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 800:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 804:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 808:	01 96       	adiw	r24, 0x01	; 1
 80a:	a1 1d       	adc	r26, r1
 80c:	b1 1d       	adc	r27, r1
 80e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 812:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 816:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 81a:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

0000081e <.Loc.117>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 81e:	e0 91 f6 00 	lds	r30, 0x00F6	; 0x8000f6 <g_callbacks+0xc>
 822:	f0 91 f7 00 	lds	r31, 0x00F7	; 0x8000f7 <g_callbacks+0xd>
 826:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 82a:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 82e:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 832:	09 95       	icall

00000834 <.Loc.119>:
    g_data_byte_one = 0;
 834:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000838 <.Loc.121>:
    g_data_byte_two = 0;
 838:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

0000083c <.LBE71>:
        return rx_status_sys_realtime_byte(byte);
 83c:	81 e0       	ldi	r24, 0x01	; 1
 83e:	08 95       	ret

00000840 <.L11>:
    ++g_message_counter;
 840:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <g_message_counter>
 844:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <g_message_counter+0x1>
 848:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <g_message_counter+0x2>
 84c:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <g_message_counter+0x3>
 850:	01 96       	adiw	r24, 0x01	; 1
 852:	a1 1d       	adc	r26, r1
 854:	b1 1d       	adc	r27, r1
 856:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <g_message_counter>
 85a:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <g_message_counter+0x1>
 85e:	a0 93 0a 01 	sts	0x010A, r26	; 0x80010a <g_message_counter+0x2>
 862:	b0 93 0b 01 	sts	0x010B, r27	; 0x80010b <g_message_counter+0x3>

00000866 <.Loc.128>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 866:	e0 91 f8 00 	lds	r30, 0x00F8	; 0x8000f8 <g_callbacks+0xe>
 86a:	f0 91 f9 00 	lds	r31, 0x00F9	; 0x8000f9 <g_callbacks+0xf>
 86e:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <g_data_byte_two>
 872:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 876:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>
 87a:	09 95       	icall

0000087c <.Loc.130>:
    g_data_byte_one = 0;
 87c:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000880 <.Loc.132>:
    g_data_byte_two = 0;
 880:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000884 <.LBE73>:
        return rx_status_sys_realtime_byte(byte);
 884:	81 e0       	ldi	r24, 0x01	; 1
 886:	08 95       	ret

00000888 <.L47>:
    g_current_channel = (byte & CHAN_MASK);
 888:	8f 70       	andi	r24, 0x0F	; 15

0000088a <.LVL30>:
 88a:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <g_current_channel>

0000088e <.Loc.142>:
    switch (type) {
 88e:	90 3b       	cpi	r25, 0xB0	; 176
 890:	31 f1       	breq	.+76     	; 0x8de <.L21>
 892:	80 f4       	brcc	.+32     	; 0x8b4 <.L22>
 894:	90 39       	cpi	r25, 0x90	; 144
 896:	f1 f0       	breq	.+60     	; 0x8d4 <.L23>
 898:	90 3a       	cpi	r25, 0xA0	; 160
 89a:	29 f4       	brne	.+10     	; 0x8a6 <.L48>

0000089c <.Loc.143>:
            g_state = STATE_WAITING_CHAN_POLY_AFTERTOUCH_KEY;
 89c:	86 e0       	ldi	r24, 0x06	; 6
 89e:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008a2 <.Loc.145>:
    return 0;
 8a2:	80 e0       	ldi	r24, 0x00	; 0

000008a4 <.Loc.147>:
            break;
 8a4:	08 95       	ret

000008a6 <.L48>:
    switch (type) {
 8a6:	90 38       	cpi	r25, 0x80	; 128
 8a8:	21 f5       	brne	.+72     	; 0x8f2 <.L26>

000008aa <.Loc.149>:
            g_state = STATE_WAITING_CHAN_NOTE_OFF_KEY;
 8aa:	82 e0       	ldi	r24, 0x02	; 2
 8ac:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008b0 <.Loc.151>:
    return 0;
 8b0:	80 e0       	ldi	r24, 0x00	; 0

000008b2 <.Loc.153>:
            break;
 8b2:	08 95       	ret

000008b4 <.L22>:
    switch (type) {
 8b4:	90 3d       	cpi	r25, 0xD0	; 208
 8b6:	c1 f0       	breq	.+48     	; 0x8e8 <.L27>
 8b8:	90 3e       	cpi	r25, 0xE0	; 224
 8ba:	29 f4       	brne	.+10     	; 0x8c6 <.L49>

000008bc <.Loc.155>:
            g_state = STATE_WAITING_CHAN_PITCH_BEND_LSBITS;
 8bc:	8c e0       	ldi	r24, 0x0C	; 12
 8be:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008c2 <.Loc.157>:
    return 0;
 8c2:	80 e0       	ldi	r24, 0x00	; 0

000008c4 <.Loc.159>:
            break;
 8c4:	08 95       	ret

000008c6 <.L49>:
    switch (type) {
 8c6:	90 3c       	cpi	r25, 0xC0	; 192
 8c8:	a1 f4       	brne	.+40     	; 0x8f2 <.L26>

000008ca <.Loc.161>:
            g_state = STATE_WAITING_CHAN_PROGRAM_CHANGE_PROGRAM;
 8ca:	8a e0       	ldi	r24, 0x0A	; 10
 8cc:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008d0 <.Loc.163>:
    return 0;
 8d0:	80 e0       	ldi	r24, 0x00	; 0

000008d2 <.Loc.165>:
            break;
 8d2:	08 95       	ret

000008d4 <.L23>:
            g_state = STATE_WAITING_CHAN_NOTE_ON_KEY;
 8d4:	84 e0       	ldi	r24, 0x04	; 4
 8d6:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008da <.Loc.168>:
    return 0;
 8da:	80 e0       	ldi	r24, 0x00	; 0

000008dc <.Loc.170>:
            break;
 8dc:	08 95       	ret

000008de <.L21>:
            g_state = STATE_WAITING_CHAN_CONTROL_CHANGE_CONTROL;
 8de:	88 e0       	ldi	r24, 0x08	; 8
 8e0:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008e4 <.Loc.173>:
    return 0;
 8e4:	80 e0       	ldi	r24, 0x00	; 0

000008e6 <.Loc.175>:
            break;
 8e6:	08 95       	ret

000008e8 <.L27>:
            g_state = STATE_WAITING_CHAN_AFTERTOUCH_PRESSURE;
 8e8:	8b e0       	ldi	r24, 0x0B	; 11
 8ea:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008ee <.Loc.178>:
    return 0;
 8ee:	80 e0       	ldi	r24, 0x00	; 0

000008f0 <.Loc.180>:
            break;
 8f0:	08 95       	ret

000008f2 <.L26>:
            g_state = STATE_ERROR;
 8f2:	81 e0       	ldi	r24, 0x01	; 1
 8f4:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000008f8 <.Loc.183>:
            return E_MIDI_BAD_CHANNEL_STATE;
 8f8:	8e ef       	ldi	r24, 0xFE	; 254
 8fa:	08 95       	ret

000008fc <.L43>:
            g_data_byte_one = byte;
 8fc:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000900 <.Loc.188>:
            g_state = STATE_WAITING_CHAN_NOTE_OFF_VELOCITY;
 900:	83 e0       	ldi	r24, 0x03	; 3

00000902 <.LVL32>:
 902:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000906 <.Loc.191>:
    return 0;
 906:	80 e0       	ldi	r24, 0x00	; 0

00000908 <.Loc.193>:
            break;
 908:	08 95       	ret

0000090a <.L42>:
            g_data_byte_two = byte;
 90a:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <g_data_byte_two>

0000090e <.LBB43>:
    ++g_message_counter;
 90e:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 912:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 916:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 91a:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 91e:	4f 5f       	subi	r20, 0xFF	; 255
 920:	5f 4f       	sbci	r21, 0xFF	; 255
 922:	6f 4f       	sbci	r22, 0xFF	; 255
 924:	7f 4f       	sbci	r23, 0xFF	; 255
 926:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 92a:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 92e:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 932:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000936 <.Loc.200>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 936:	e0 91 fa 00 	lds	r30, 0x00FA	; 0x8000fa <g_callbacks+0x10>
 93a:	f0 91 fb 00 	lds	r31, 0x00FB	; 0x8000fb <g_callbacks+0x11>
 93e:	48 2f       	mov	r20, r24
 940:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 944:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000948 <.LVL35>:
 948:	09 95       	icall

0000094a <.LVL36>:
    g_data_byte_one = 0;
 94a:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

0000094e <.Loc.205>:
    g_data_byte_two = 0;
 94e:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000952 <.LBE43>:
            g_state = STATE_WAITING_CHAN_NOTE_OFF_KEY;
 952:	82 e0       	ldi	r24, 0x02	; 2
 954:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000958 <.Loc.210>:
            return 1;
 958:	81 e0       	ldi	r24, 0x01	; 1
 95a:	08 95       	ret

0000095c <.L41>:
            g_data_byte_one = byte;
 95c:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000960 <.Loc.214>:
            g_state = STATE_WAITING_CHAN_NOTE_ON_VELOCITY;
 960:	85 e0       	ldi	r24, 0x05	; 5

00000962 <.LVL39>:
 962:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000966 <.Loc.217>:
    return 0;
 966:	80 e0       	ldi	r24, 0x00	; 0

00000968 <.Loc.219>:
            break;
 968:	08 95       	ret

0000096a <.L40>:
            g_data_byte_two = byte;
 96a:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <g_data_byte_two>

0000096e <.LBB45>:
    ++g_message_counter;
 96e:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 972:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 976:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 97a:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 97e:	4f 5f       	subi	r20, 0xFF	; 255
 980:	5f 4f       	sbci	r21, 0xFF	; 255
 982:	6f 4f       	sbci	r22, 0xFF	; 255
 984:	7f 4f       	sbci	r23, 0xFF	; 255
 986:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 98a:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 98e:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 992:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000996 <.Loc.226>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 996:	e0 91 fc 00 	lds	r30, 0x00FC	; 0x8000fc <g_callbacks+0x12>
 99a:	f0 91 fd 00 	lds	r31, 0x00FD	; 0x8000fd <g_callbacks+0x13>
 99e:	48 2f       	mov	r20, r24
 9a0:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 9a4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

000009a8 <.LVL42>:
 9a8:	09 95       	icall

000009aa <.LVL43>:
    g_data_byte_one = 0;
 9aa:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

000009ae <.Loc.231>:
    g_data_byte_two = 0;
 9ae:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

000009b2 <.LBE45>:
            g_state = STATE_WAITING_CHAN_NOTE_ON_KEY;
 9b2:	84 e0       	ldi	r24, 0x04	; 4
 9b4:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000009b8 <.Loc.236>:
            return 1;
 9b8:	81 e0       	ldi	r24, 0x01	; 1
 9ba:	08 95       	ret

000009bc <.L39>:
            g_data_byte_one = byte;
 9bc:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

000009c0 <.Loc.240>:
            g_state = STATE_WAITING_CHAN_POLY_AFTERTOUCH_PRESSURE;
 9c0:	87 e0       	ldi	r24, 0x07	; 7

000009c2 <.LVL46>:
 9c2:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

000009c6 <.Loc.243>:
    return 0;
 9c6:	80 e0       	ldi	r24, 0x00	; 0

000009c8 <.Loc.245>:
            break;
 9c8:	08 95       	ret

000009ca <.L38>:
            g_data_byte_two = byte;
 9ca:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <g_data_byte_two>

000009ce <.LBB47>:
    ++g_message_counter;
 9ce:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 9d2:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 9d6:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 9da:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 9de:	4f 5f       	subi	r20, 0xFF	; 255
 9e0:	5f 4f       	sbci	r21, 0xFF	; 255
 9e2:	6f 4f       	sbci	r22, 0xFF	; 255
 9e4:	7f 4f       	sbci	r23, 0xFF	; 255
 9e6:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 9ea:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 9ee:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 9f2:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

000009f6 <.Loc.252>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 9f6:	e0 91 fe 00 	lds	r30, 0x00FE	; 0x8000fe <g_callbacks+0x14>
 9fa:	f0 91 ff 00 	lds	r31, 0x00FF	; 0x8000ff <g_callbacks+0x15>
 9fe:	48 2f       	mov	r20, r24
 a00:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 a04:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000a08 <.LVL49>:
 a08:	09 95       	icall

00000a0a <.LVL50>:
    g_data_byte_one = 0;
 a0a:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000a0e <.Loc.257>:
    g_data_byte_two = 0;
 a0e:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000a12 <.LBE47>:
            g_state = STATE_WAITING_CHAN_POLY_AFTERTOUCH_KEY;
 a12:	86 e0       	ldi	r24, 0x06	; 6
 a14:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000a18 <.Loc.262>:
            return 1;
 a18:	81 e0       	ldi	r24, 0x01	; 1
 a1a:	08 95       	ret

00000a1c <.L37>:
            g_data_byte_one = byte;
 a1c:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000a20 <.Loc.266>:
            g_state = STATE_WAITING_CHAN_CONTROL_CHANGE_VALUE;
 a20:	89 e0       	ldi	r24, 0x09	; 9

00000a22 <.LVL53>:
 a22:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000a26 <.Loc.269>:
    return 0;
 a26:	80 e0       	ldi	r24, 0x00	; 0

00000a28 <.Loc.271>:
            break;
 a28:	08 95       	ret

00000a2a <.L36>:
            g_data_byte_two = byte;
 a2a:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <g_data_byte_two>

00000a2e <.LBB49>:
    ++g_message_counter;
 a2e:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 a32:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 a36:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 a3a:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 a3e:	4f 5f       	subi	r20, 0xFF	; 255
 a40:	5f 4f       	sbci	r21, 0xFF	; 255
 a42:	6f 4f       	sbci	r22, 0xFF	; 255
 a44:	7f 4f       	sbci	r23, 0xFF	; 255
 a46:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 a4a:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 a4e:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 a52:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000a56 <.Loc.278>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 a56:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <g_callbacks+0x16>
 a5a:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <g_callbacks+0x17>
 a5e:	48 2f       	mov	r20, r24
 a60:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 a64:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000a68 <.LVL56>:
 a68:	09 95       	icall

00000a6a <.LVL57>:
    g_data_byte_one = 0;
 a6a:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000a6e <.Loc.283>:
    g_data_byte_two = 0;
 a6e:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000a72 <.LBE49>:
            g_state = STATE_WAITING_CHAN_CONTROL_CHANGE_CONTROL;
 a72:	88 e0       	ldi	r24, 0x08	; 8
 a74:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000a78 <.Loc.288>:
            return 1;
 a78:	81 e0       	ldi	r24, 0x01	; 1
 a7a:	08 95       	ret

00000a7c <.L35>:
            g_data_byte_one = byte;
 a7c:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000a80 <.Loc.292>:
            g_data_byte_two = 0;
 a80:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000a84 <.LBB51>:
    ++g_message_counter;
 a84:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 a88:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 a8c:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 a90:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 a94:	4f 5f       	subi	r20, 0xFF	; 255
 a96:	5f 4f       	sbci	r21, 0xFF	; 255
 a98:	6f 4f       	sbci	r22, 0xFF	; 255
 a9a:	7f 4f       	sbci	r23, 0xFF	; 255
 a9c:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 aa0:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 aa4:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 aa8:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000aac <.Loc.298>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 aac:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <g_callbacks+0x18>
 ab0:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <g_callbacks+0x19>
 ab4:	40 e0       	ldi	r20, 0x00	; 0
 ab6:	68 2f       	mov	r22, r24
 ab8:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000abc <.LVL61>:
 abc:	09 95       	icall

00000abe <.LVL62>:
    g_data_byte_one = 0;
 abe:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000ac2 <.Loc.303>:
    g_data_byte_two = 0;
 ac2:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000ac6 <.LBE51>:
            return 1;
 ac6:	81 e0       	ldi	r24, 0x01	; 1
 ac8:	08 95       	ret

00000aca <.L34>:
            g_data_byte_one = byte;
 aca:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000ace <.Loc.308>:
            g_data_byte_two = 0;
 ace:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000ad2 <.LBB53>:
    ++g_message_counter;
 ad2:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 ad6:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 ada:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 ade:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 ae2:	4f 5f       	subi	r20, 0xFF	; 255
 ae4:	5f 4f       	sbci	r21, 0xFF	; 255
 ae6:	6f 4f       	sbci	r22, 0xFF	; 255
 ae8:	7f 4f       	sbci	r23, 0xFF	; 255
 aea:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 aee:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 af2:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 af6:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000afa <.Loc.314>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 afa:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <g_callbacks+0x1a>
 afe:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <g_callbacks+0x1b>
 b02:	40 e0       	ldi	r20, 0x00	; 0
 b04:	68 2f       	mov	r22, r24
 b06:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000b0a <.LVL65>:
 b0a:	09 95       	icall

00000b0c <.LVL66>:
    g_data_byte_one = 0;
 b0c:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000b10 <.Loc.319>:
    g_data_byte_two = 0;
 b10:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000b14 <.LBE53>:
            return 1;
 b14:	81 e0       	ldi	r24, 0x01	; 1
 b16:	08 95       	ret

00000b18 <.L33>:
            g_data_byte_one = byte;
 b18:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <g_data_byte_one>

00000b1c <.Loc.324>:
            g_state = STATE_WAITING_CHAN_PITCH_BEND_MSBITS;
 b1c:	8d e0       	ldi	r24, 0x0D	; 13

00000b1e <.LVL68>:
 b1e:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000b22 <.Loc.327>:
    return 0;
 b22:	80 e0       	ldi	r24, 0x00	; 0

00000b24 <.Loc.329>:
            break;
 b24:	08 95       	ret

00000b26 <.L31>:
            g_data_byte_two = byte;
 b26:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <g_data_byte_two>

00000b2a <.LBB55>:
    ++g_message_counter;
 b2a:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <g_message_counter>
 b2e:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <g_message_counter+0x1>
 b32:	60 91 0a 01 	lds	r22, 0x010A	; 0x80010a <g_message_counter+0x2>
 b36:	70 91 0b 01 	lds	r23, 0x010B	; 0x80010b <g_message_counter+0x3>
 b3a:	4f 5f       	subi	r20, 0xFF	; 255
 b3c:	5f 4f       	sbci	r21, 0xFF	; 255
 b3e:	6f 4f       	sbci	r22, 0xFF	; 255
 b40:	7f 4f       	sbci	r23, 0xFF	; 255
 b42:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <g_message_counter>
 b46:	50 93 09 01 	sts	0x0109, r21	; 0x800109 <g_message_counter+0x1>
 b4a:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <g_message_counter+0x2>
 b4e:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <g_message_counter+0x3>

00000b52 <.Loc.336>:
    (g_callbacks[evt])(g_current_channel, g_data_byte_one, g_data_byte_two);
 b52:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <g_callbacks+0x1c>
 b56:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <g_callbacks+0x1d>
 b5a:	48 2f       	mov	r20, r24
 b5c:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <g_data_byte_one>
 b60:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <g_current_channel>

00000b64 <.LVL71>:
 b64:	09 95       	icall

00000b66 <.LVL72>:
    g_data_byte_one = 0;
 b66:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000b6a <.Loc.341>:
    g_data_byte_two = 0;
 b6a:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000b6e <.LBE55>:
            g_state = STATE_WAITING_CHAN_PITCH_BEND_LSBITS;
 b6e:	8c e0       	ldi	r24, 0x0C	; 12
 b70:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_state>

00000b74 <.Loc.346>:
            return 1;
 b74:	81 e0       	ldi	r24, 0x01	; 1
 b76:	08 95       	ret

00000b78 <.L30>:
            g_data_byte_one = 0;
 b78:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_data_byte_one>

00000b7c <.Loc.350>:
            g_data_byte_two = 0;
 b7c:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <g_data_byte_two>

00000b80 <.Loc.352>:
    return 0;
 b80:	80 e0       	ldi	r24, 0x00	; 0

00000b82 <.LVL75>:
            break;
 b82:	08 95       	ret

00000b84 <.L44>:
    if ((byte & SYS_REALTIME_MASK) == SYS_REALTIME_MASK) {
 b84:	81 e0       	ldi	r24, 0x01	; 1

00000b86 <.LVL77>:
 b86:	08 95       	ret

00000b88 <.L45>:
        return rx_status_sys_common_byte(byte);
 b88:	80 e0       	ldi	r24, 0x00	; 0

00000b8a <.LVL79>:
    } else {
        // The byte is a regular data byte.
        g_debug_last_data_byte = byte;
        return rx_data_byte(byte);
    }
}
 b8a:	08 95       	ret

00000b8c <eeprom_read_byte>:
 b8c:	e1 99       	sbic	0x1c, 1	; 28
 b8e:	fe cf       	rjmp	.-4      	; 0xb8c <eeprom_read_byte>
 b90:	9f bb       	out	0x1f, r25	; 31
 b92:	8e bb       	out	0x1e, r24	; 30
 b94:	e0 9a       	sbi	0x1c, 0	; 28
 b96:	99 27       	eor	r25, r25
 b98:	8d b3       	in	r24, 0x1d	; 29
 b9a:	08 95       	ret

00000b9c <_exit>:
 b9c:	f8 94       	cli

00000b9e <__stop_program>:
 b9e:	ff cf       	rjmp	.-2      	; 0xb9e <__stop_program>

00000ba0 <L0^A>:
 ba0:	b4 ca       	rjmp	.-2712   	; 0x10a <.L11>
 ba2:	b5 ca       	rjmp	.-2710   	; 0x10e <.L10>
 ba4:	b6 ca       	rjmp	.-2708   	; 0x112 <.L9>
 ba6:	b7 ca       	rjmp	.-2706   	; 0x116 <.L8>
 ba8:	b8 ca       	rjmp	.-2704   	; 0x11a <.L7>
 baa:	b9 ca       	rjmp	.-2702   	; 0x11e <.L6>
 bac:	ba ca       	rjmp	.-2700   	; 0x122 <.L5>
 bae:	bb ca       	rjmp	.-2698   	; 0x126 <.L3>

00000bb0 <.L15>:
 bb0:	c3 ca       	rjmp	.-2682   	; 0x138 <.L22>
 bb2:	c4 ca       	rjmp	.-2680   	; 0x13c <.L21>
 bb4:	c5 ca       	rjmp	.-2678   	; 0x140 <.L20>
 bb6:	c6 ca       	rjmp	.-2676   	; 0x144 <.L19>
 bb8:	c7 ca       	rjmp	.-2674   	; 0x148 <.L18>
 bba:	c8 ca       	rjmp	.-2672   	; 0x14c <.L17>
 bbc:	c9 ca       	rjmp	.-2670   	; 0x150 <.L16>
 bbe:	ca ca       	rjmp	.-2668   	; 0x154 <.L14>

00000bc0 <.L32>:
 bc0:	9d ce       	rjmp	.-710    	; 0x8fc <.L43>
 bc2:	a3 ce       	rjmp	.-698    	; 0x90a <.L42>
 bc4:	cb ce       	rjmp	.-618    	; 0x95c <.L41>
 bc6:	d1 ce       	rjmp	.-606    	; 0x96a <.L40>
 bc8:	f9 ce       	rjmp	.-526    	; 0x9bc <.L39>
 bca:	ff ce       	rjmp	.-514    	; 0x9ca <.L38>
 bcc:	27 cf       	rjmp	.-434    	; 0xa1c <.L37>
 bce:	2d cf       	rjmp	.-422    	; 0xa2a <.L36>
 bd0:	55 cf       	rjmp	.-342    	; 0xa7c <.L35>
 bd2:	7b cf       	rjmp	.-266    	; 0xaca <.L34>
 bd4:	a1 cf       	rjmp	.-190    	; 0xb18 <.L33>
 bd6:	a7 cf       	rjmp	.-178    	; 0xb26 <.L31>

00000bd8 <.L12>:
 bd8:	37 cd       	rjmp	.-1426   	; 0x648 <.L19>
 bda:	5a cd       	rjmp	.-1356   	; 0x690 <.L18>
 bdc:	7d cd       	rjmp	.-1286   	; 0x6d8 <.L17>
 bde:	a0 cd       	rjmp	.-1216   	; 0x720 <.L16>
 be0:	c3 cd       	rjmp	.-1146   	; 0x768 <.L15>
 be2:	e6 cd       	rjmp	.-1076   	; 0x7b0 <.L14>
 be4:	09 ce       	rjmp	.-1006   	; 0x7f8 <.L13>
 be6:	2c ce       	rjmp	.-936    	; 0x840 <.L11>
